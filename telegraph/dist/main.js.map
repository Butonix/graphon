{"version":3,"sources":["webpack://Telegraph/webpack/bootstrap","webpack://Telegraph/./src/modules/state.js","webpack://Telegraph/./src/utils/dom.js","webpack://Telegraph/./src/utils/event.js","webpack://Telegraph/./src/utils/debounce.js","webpack://Telegraph/./src/utils/numbers.js","webpack://Telegraph/./src/modules/path.js","webpack://Telegraph/./src/modules/graph.js","webpack://Telegraph/./src/modules/minimap.js","webpack://Telegraph/./src/modules/tooltip.js","webpack://Telegraph/./src/modules/chart.js","webpack://Telegraph/./src/modules/legend.js","webpack://Telegraph/./src/telegraph.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACe;AACf;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,C;;ACzGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA,YAAY;AACZ;AACO,8DAA8D;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA,C;;AC1CA;AACA;AACA,WAAW,sBAAsB;AACjC;AACO;AACP;AACA;AACA;;AAEA;AACA,C;;ACVA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;ACpBO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,C;;ACnBoC;;AAEpC;AACA;AACA;AACe,MAAM,SAAI;AACzB,eAAe,4CAA4C;AAC3D;AACA;AACA;AACA;;AAEA,gBAAgB,IAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,0BAA0B,UAAU,GAAG,UAAU;AACjD;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB,GAAG,UAAU;AAC3D;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,2BAA2B,UAAU,GAAG,UAAU;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oFAAoF,QAAQ;AAC5F,KAAK;AACL,4DAA4D,QAAQ;AACpE;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oFAAoF,QAAQ;AAC5F,KAAK;AACL,4DAA4D,QAAQ;AACpE;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA,wCAAwC,SAAI;AAC5C;;AAEA;AACA,+BAA+B,SAAI;AACnC;AACA,C;;ACxLoC;AACQ;AAClB;;AAE1B;AACA;AACA;AACe,MAAM,WAAK;AAC1B;AACA,aAAa,MAAM;AACnB;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA,gBAAgB,cAAc,KAAK;AACnC,kBAAkB,IAAQ;;AAE1B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAI;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,kBAAkB,IAAQ,QAAQ,WAAK;AACvC;AACA,MAAM,YAAgB;AACtB;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,WAAK;AAChC,OAAO;AACP;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA,OAAO;AACP,eAAe,IAAQ,QAAQ,WAAK;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,WAAK;AACjC;AACA,yBAAyB,QAAgB;AACzC;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,IAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,IAAQ;AAC7B;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL,IAAI,WAAe;AACnB;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,WAAW;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;ACxUuC;AACI;AACC;AACb;;;AAG/B;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAM,eAAO;AAC5B;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,WAAK;AAC1B;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,IAAQ,QAAQ,eAAO;AAChD,0BAA0B,IAAQ,QAAQ,eAAO;AACjD,2BAA2B,IAAQ,QAAQ,eAAO;AAClD,gCAAgC,IAAQ,QAAQ,eAAO;AACvD,iCAAiC,IAAQ,QAAQ,eAAO;;AAExD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,WAAW,OAAO;;AAElB;;AAEA,mDAAmD,eAAO,oBAAoB;AAC9E,oDAAoD,eAAO,qBAAqB;;AAEhF;AACA,sBAAsB,QAAc;;AAEpC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA,gBAAgB,QAAc;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,OAAO;AACpB;AACA;AACA,gBAAgB,QAAc;AAC9B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,C;;ACzZuC;AACK;;AAE7B,MAAM,eAAO;AAC5B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,IAAQ,QAAQ,eAAO;AAChD,uBAAuB,IAAQ,QAAQ,eAAO;AAC9C,wBAAwB,IAAQ,QAAQ,eAAO;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,eAAO;AAC5C;;AAEA;AACA,wCAAwC,eAAO;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,uCAAuC,2BAA2B;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B,GAAG;AAC7C;AACA;AACA;;AAEA,sBAAsB,YAAY;AAClC,mBAAmB,IAAQ,QAAQ,eAAO;AAC1C;AACA;;;AAGA,6BAA6B,QAAgB,QAAQ,MAAM,MAAM;AACjE;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,C;;AC5FuC;AACR;AACC;AACW;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAM,WAAK;AAC1B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,eAAO;AAC9B,qBAAqB,WAAK;AAC1B;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,IAAQ,QAAQ,WAAK;AAC9C,0BAA0B,IAAQ,QAAQ,WAAK;AAC/C,4BAA4B,IAAQ,QAAQ,WAAK;;AAEjD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA,2CAA2C,WAAK;AAChD;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,YAAY,QAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD,wCAAwC,WAAK;;AAE7C;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,2CAA2C,WAAK;AAChD;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,C;;ACtSuC;;AAExB,MAAM,aAAM;AAC3B;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,IAAQ,QAAQ,aAAM;;AAE/C;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;;AAEL,yBAAyB,YAAY;AACrC,iBAAiB,IAAQ,SAAS,aAAM,WAAW,aAAM;AACzD,mBAAmB,IAAQ,SAAS,aAAM;;AAE1C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA,wCAAwC,aAAM;;AAE9C,0DAA0D,aAAM,cAAc;;AAE9E;AACA;AACA;AACA,8CAA8C,aAAM;AACpD,qDAAqD,gCAAgC;AACrF,KAAK;AACL;AACA;AACA;AACA;AACA;;;ACjFA;AAAoC;AACO;AACJ;AACE;;AAEzC;AACA,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,wBAAwB;AACvC;;AAEe,MAAM,mBAAS;AAC9B;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA,eAAe,oBAAoB;AACnC;;AAEA;AACA;AACA;AACA,qBAAqB,KAAK;;AAE1B;AACA;AACA;AACA,uBAAuB,eAAO;;AAE9B;AACA;AACA;AACA,qBAAqB,WAAK;;AAE1B;AACA;AACA;AACA,sBAAsB,aAAM;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAS;AAC1C;AACA,C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * This class stores the sate of application\n * @todo add cache to all getters\n */\nexport default class State {\n  /**\n   * @param {ChartData} chartsData - input data\n   */\n  constructor(chartsData){\n    this.columns = chartsData.columns;\n    this.colors = chartsData.colors;\n    this.names = chartsData.names;\n    this.types = chartsData.types;\n  }\n\n  /**\n   * Column with dates is 0-index column, so shift it\n   * First element in arrays is column name (\"x\") so slice it\n   * @return {number[]} - array of dates in milliseconds\n   */\n  get dates(){\n    return this.columns[0].slice(1);\n  }\n\n  /**\n   * Return available line names\n   * @return {string[]} - array of graph names\n   */\n  get linesAvailable(){\n    return Object.keys(this.names);\n  }\n\n  /**\n   * Returns numbers of days at the input data\n   * @return {number}\n   */\n  get daysCount(){\n    return this.columns[0].length - 1; // -1 because the first element is column type (\"x\")\n  }\n\n  /**\n   * Returns values of line by line name\n   * @param {string} lineName - \"y0\", \"y1\" etc\n   * @return {number[]}\n   */\n  getLinePoints(lineName){\n    return this.getColumnByName(lineName).slice(1); // slice 0-element because it is a column name\n  }\n\n  /**\n   * Return column by name\n   * @param {string} name - \"y0\", \"y1\" etc\n   * @return {array}\n   */\n  getColumnByName(name){\n    return this.columns[this.columns.findIndex(column => column[0] === name)];\n  }\n\n  /**\n   * Return N points from passed position\n   * @param {string} lineName - \"y0\", \"y1\", ...etc\n   * @param {number} from - start position\n   * @param {number} count - how many items requested\n   * @return {number[]}\n   */\n  getPointsSlice(lineName, from, count){\n    return this.getLinePoints(lineName).slice(from, from + count);\n  }\n\n  /**\n   * Returns color of line by line name\n   * @param {string} lineName - \"y0\", \"y1\" etc\n   * @return {string} - hex color like \"#333333\"\n   */\n  getLineColor(lineName){\n    return this.colors[lineName];\n  }\n\n  /**\n   * Return maximum value from all charts\n   * @return {number}\n   */\n  get max(){\n    const maxPerLines = this.linesAvailable.map( name => {\n      return Math.max(...this.getLinePoints(name));\n    });\n\n    return Math.max(...maxPerLines);\n  }\n\n  /**\n   * Array of available colors\n   * @return {string[]}\n   */\n  get colorsList(){\n    return Object.entries(this.colors).map(([name, value]) => value);\n  }\n\n  /**\n   * Array of available chart names\n   * @return {string[]}\n   */\n  get namesList(){\n    return Object.entries(this.names).map(([name, value]) => value);\n  }\n}","/**\n * Create HTML element\n * @param {string} tagName - HTML element tag name\n * @param {string[]|string} classNames - array of CSS classes\n * @param attributes - any attributes\n * @return {HTMLElement}\n */\nexport function make(tagName, classNames = undefined, attributes = {}) {\n  const svgNamespace = 'http://www.w3.org/2000/svg';\n  const svgElements = ['svg', 'path', 'rect', 'circle', 'text'];\n  const isSvg = svgElements.includes(tagName);\n  const el = !isSvg ? document.createElement(tagName) : document.createElementNS(svgNamespace, tagName);\n\n  if (Array.isArray(classNames) && classNames.length) {\n    el.classList.add(...classNames);\n  } else if (classNames) {\n    el.className = classNames;\n  }\n\n  if (attributes && Object.keys(attributes).length) {\n    for (let attrName in attributes) {\n      if (attributes.hasOwnProperty(attrName)) {\n        el.setAttribute(attrName, attributes[attrName]);\n      }\n    }\n  }\n\n  return el;\n}\n\n/**\n * Inserts one element after another\n */\nexport function insertAfter(target, element) {\n  target.parentNode.insertBefore(element, target.nextSibling);\n}\n\n/**\n * Insert one element before another\n */\nexport function insertBefore(target, element) {\n  target.parentNode.insertBefore(element, target);\n}","/**\n * Return pageX for passed Event\n * @param {MouseEvent|TouchEvent} event\n */\nexport function getPageX(event) {\n  if (event.touches){\n    return event.touches[0].pageX;\n  }\n\n  return event.pageX;\n}","/**\n * Invoke a function with debounce\n * @param {function} func - callback\n * @param {number} wait - how many second should be awaited before calling a callback\n * @param {boolean} immediate - pass true to call immediately\n * @return {Function}\n */\nexport default function debounce(func, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};","export function beautify(number) {\n  if (number < 1000) {\n    return number\n  } else if (number < 10000){\n      let thousands = Math.floor(number / 1000);\n      let left = number - thousands * 1000;\n\n      if (left > 100){\n        return thousands + ' ' + left;\n      } else if (left > 10) {\n        return thousands + ' 0' + left;\n      } else {\n        return thousands + ' 00' + left;\n      }\n  } else if (number < 1000000) {\n      return Math.floor(number / 1000) + 'k';\n  } else {\n    return Math.floor(number / 1000000) + 'M';\n  }\n}","import * as Dom from \"../utils/dom\";\n\n/**\n * Helper for creating an SVG path\n */\nexport default class Path {\n  constructor({color, svg, max, stroke, stepX, opacity = 1}){\n    this.svg = svg;\n    this.kY = max !== 0 ? this.canvasHeight / max : 1;\n    this.stepX = stepX;\n    this.prevX = 0;\n\n    this.path = Dom.make('path', null, {\n      'stroke-width' : stroke,\n      stroke : color,\n      fill : 'transparent',\n      'stroke-linecap' : 'round',\n      'stroke-linejoin' : 'round',\n      'vector-effect': 'non-scaling-stroke',\n      opacity\n    });\n\n    this.pathData = '';\n  }\n\n  static get CSS(){\n    return {\n      graphHidden: 'tg-graph--hidden'\n    }\n  }\n\n  /**\n   * @todo get offsetHeight instead of style.height\n   * @todo cache value\n   * @return {number}\n   */\n  get canvasHeight(){\n    return parseInt(this.svg.style.height, 10);\n  }\n\n  get canvasWidth(){\n    return this.svg.offsetWidth;\n  }\n\n  /**\n   * Compute Y value with scaling\n   */\n  y(val){\n    return Math.round(this.canvasHeight - val * this.kY);\n  }\n\n  /**\n   * Compute X value with scaling\n   */\n  x(val){\n    return val;\n  }\n\n  /**\n   * Go to passed coords\n   * @param {number} x\n   * @param {number} y\n   */\n  moveTo(x, y){\n    this.pathData += `M ${this.x(x)} ${this.y(y)}`;\n  }\n\n  /**\n   * Continue line to the next value\n   * @param {number} y\n   */\n  stepTo(y, skipStep){\n    if (!skipStep){\n      this.prevX = this.prevX + this.stepX;\n    }\n    this.pathData += ` L ${this.x(this.prevX)} ${this.y(y)}`;\n  }\n\n  /**\n   * Create a new line with x and y\n   * @param {number} x\n   * @param {number} y\n   */\n  lineTo(x, y){\n    this.pathData += ` L ${this.x(x)} ${this.y(y)}`;\n  }\n\n  /**\n   * Append a line\n   */\n  render(){\n    this.path.setAttribute('d', this.pathData);\n    this.svg.appendChild(this.path);\n    this.animate();\n  }\n\n  /**\n   * Drop text to passed point\n   * @param value\n   */\n  dropText(value, skipStepX = false){\n    let text = Dom.make('text', null, {\n      x: !skipStepX ? this.prevX + this.stepX: this.prevX,\n      y: this.y(value),\n      fill: '#cccccc',\n      textAnchor: 'left',\n      'dominant-baseline': 'use-script'\n    })\n\n    text.appendChild(document.createTextNode(value));\n    text.style.fontSize = 13 + 'px';\n\n    this.svg.appendChild(text);\n  }\n\n  animate(){\n    const speed = 2000;\n    const length = this.path.getTotalLength();\n\n    // Clear any previous transition\n    this.path.style.transition = this.path.style.WebkitTransition = 'none';\n\n    // Set up the starting position\n    this.path.style.strokeDasharray = length + ' ' + length;\n    this.path.style.strokeDashoffset = length;\n\n    // Trigger a Layout so styles are re-calculated\n    // A browser picks up the starting position before animating\n    this.path.getBoundingClientRect();\n\n    // Define our transition\n    this.path.style.transition = this.path.style.WebkitTransition = 'stroke-dashoffset ' + speed + 'ms' + ' ease-in';\n\n    // Go.\n    this.path.style.strokeDashoffset = '0';\n\n    setTimeout(() => {\n      this.path.style.removeProperty('transition');\n      this.path.style.removeProperty('stroke-dasharray');\n      this.path.style.removeProperty('stroke-dashoffset');\n    }, speed)\n  };\n\n  scaleX(scaling){\n    let oldTransform = this.path.style.transform;\n    // let oldTransition = this.path.style.transition;\n\n    // this.path.style.transition = 'transform 100ms ease, opacity 150ms ease';\n\n    if (oldTransform.includes('scaleX')){\n      this.path.style.transform = oldTransform.replace(/(scaleX\\(\\S+\\))/, `scaleX(${scaling})`)\n    } else {\n      this.path.style.transform = oldTransform + ` scaleX(${scaling})`;\n    }\n\n    // setTimeout(() => {\n    //   this.path.style.transition = oldTransition;\n    // }, 100)\n  }\n\n  scaleY(scaling){\n    let oldTransform = this.path.style.transform;\n    let oldTransition = this.path.style.transition;\n\n      this.path.style.transition = 'transform 150ms ease-out, opacity 150ms ease';\n\n    if (oldTransform.includes('scaleY')){\n      this.path.style.transform = oldTransform.replace(/(scaleY\\(\\S+\\))/, `scaleY(${scaling})`)\n    } else {\n      this.path.style.transform = oldTransform + ` scaleY(${scaling})`;\n    }\n\n      setTimeout(() => {\n        this.path.style.transition = oldTransition;\n      }, 300)\n  }\n\n  get isHidden(){\n    return this.path.classList.contains(Path.CSS.graphHidden);\n  }\n\n  toggleVisibility(){\n    this.path.classList.toggle(Path.CSS.graphHidden);\n  }\n}","import * as Dom from '../utils/dom';\nimport * as Numbers from '../utils/numbers';\nimport Path from './path';\n\n/**\n * Working with svg paths for charts\n */\nexport default class Graph {\n  /**\n   * @param {State} state\n   */\n  constructor(state, {stroke}){\n    /**\n     * Width of date label is used for default stepX value in 1:1 scale\n     * @type {number}\n     */\n    const dateLabelWidth = 45;\n\n    this.state = state;\n    /**\n     * @todo move to this.nodes\n     */\n    this.canvas = undefined;\n    this.legend = undefined;\n    this.grid = undefined;\n    this.gridLines = [];\n\n\n    this.stepX = dateLabelWidth;\n    this.stepY = 10;\n    this.strokeWidth = stroke;\n    this.initialWidth = undefined;\n    this.maxPoint = this.state.max * 1.2; // 20% for padding top\n\n    /**\n     * List of drawn lines\n     * @type {object} name -> Path\n     */\n    this.paths = {};\n  }\n\n  static get CSS(){\n    return {\n      grid: 'tg-grid',\n      gridSection: 'tg-grid__section',\n      gridSectionHidden: 'tg-grid__section--hidden'\n    }\n  }\n\n  /**\n   * Return Graph's paths as array\n   * @return {Path[]}\n   */\n  get pathsList(){\n    return Object.entries(this.paths).map(([name, path]) => {\n      return path;\n    });\n  }\n\n\n  /**\n   * Prepares the SVG element\n   * @param {number} [width] - strict canvas width\n   * @param {number} [height] - strict canvas height\n   * @return {SVGElement}\n   */\n  renderCanvas({width, height} = {}){\n    this.canvas = Dom.make('svg');\n\n    if (!width){\n      this.setCanvasWidth();\n    } else {\n      this.canvas.style.width = width + 'px';\n      this.initialWidth = width;\n    }\n\n    if (height){\n      this.canvas.style.height = height + 'px';\n    }\n\n    this.computeSteps();\n\n    return this.canvas;\n  }\n\n  /**\n   * Compute and set initial canvas width\n   */\n  setCanvasWidth(){\n    this.initialWidth = this.state.daysCount * this.stepX;\n    this.canvas.style.width = this.initialWidth + 'px';\n  }\n\n  /**\n   * Return total (big) chart width\n   * @return {number}\n   */\n  get width(){\n    return parseInt(this.canvas.style.width, 10);\n  }\n\n  /**\n   * Return chart height\n   * @return {number}\n   */\n  get height(){\n    return parseInt(this.canvas.style.height, 10);\n  }\n\n  /**\n   * Calculates stepX by canvas width and total points count\n   */\n  computeSteps(){\n    this.stepX = parseInt(this.canvas.style.width, 10) / this.state.daysCount;\n\n    /**\n     * All lines maximum value\n     */\n    const max = this.state.max;\n    const stepsAvailable = [5, 10, 25, 50, 100, 1000, 500, 10000, 5000, 100000, 1000000, 10000000];\n    let newStepYIndex = stepsAvailable.reverse().findIndex( step => max > step ),\n    newStepY = stepsAvailable[newStepYIndex];\n\n    if (max / newStepY < 3 && newStepYIndex < stepsAvailable.length - 1){\n      newStepY = stepsAvailable[newStepYIndex + 1];\n    }\n\n    this.stepY = newStepY;\n  }\n\n\n  /**\n   * Renders a line by name\n   * @param {string} name - line name (\"y0\", \"y1\" etc)\n   */\n  renderLine(name){\n    /**\n     * Array of chart Y values\n     */\n    const values = this.state.getLinePoints(name);\n\n    /**\n     * Color of drawing line\n     */\n    const color = this.state.getLineColor(name);\n\n    /**\n     * Point to from which we will start drawing\n     */\n    const leftPoint = values[0];\n\n    /**\n     * Create a Path instance\n     */\n    const path = new Path({\n      svg: this.canvas,\n      color,\n      max: this.maxPoint,\n      stroke: this.strokeWidth,\n      stepX: this.stepX,\n    });\n\n    path.moveTo(0, leftPoint);\n\n    values.forEach( (column, index )=> {\n      if (index === 0){\n        // path.dropText(column, true);\n        path.stepTo(column, true);\n      } else {\n        // path.dropText(column);\n        path.stepTo(column);\n      }\n\n    });\n\n    path.render();\n\n    this.paths[name] = path;\n  }\n\n  /**\n   * Render or updates a grid\n   * @param {number} forceMax - new max value for updating\n   * @param {boolean} isUpdating - true for updating\n   */\n  renderGrid(forceMax, isUpdating = false){\n    if (!this.grid) {\n      this.grid = Dom.make('div', Graph.CSS.grid);\n      this.gridLines = [];\n      Dom.insertBefore(this.canvas.parentNode, this.grid);\n    }\n\n\n\n    let stepY = this.stepY;\n    const height = this.height;\n    const width = this.width;\n    const max = forceMax || this.maxPoint;\n    const kY = height / max;\n\n    let linesCount = height / (stepY * kY) >> 0;\n\n    if (linesCount === 0){\n      stepY = stepY / 3;\n      linesCount = height / (stepY * kY) >> 0;\n    }\n\n    if (linesCount === 1){\n      stepY = stepY / 2;\n      linesCount = height / (stepY * kY) >> 0;\n    }\n\n    if (this.gridLines.length){\n      this.gridLines.forEach( line => {\n        line.classList.add(Graph.CSS.gridSectionHidden);\n      })\n    }\n\n    // Drawing horizontal lines\n\n    for (let j = 0; j <= linesCount; j++) {\n      let y = j * stepY;\n      let line;\n\n      if (this.gridLines.length && this.gridLines[j]){\n        line = this.gridLines[j];\n      } else {\n        line = Dom.make('div', Graph.CSS.gridSection);\n        this.grid.appendChild(line);\n        this.gridLines.push(line);\n      }\n\n      if (j === 0){\n        line.classList.add('no-animation');\n      }\n\n      line.classList.remove(Graph.CSS.gridSectionHidden);\n      line.style.bottom = y * kY + 'px';\n      line.textContent = Numbers.beautify(Math.round(y));\n    }\n  }\n\n  /**\n   * Renders a legend with dates\n   * @param {number[]} dates\n   */\n  renderLegend(dates){\n    this.legend = Dom.make('footer');\n\n    dates.forEach((date, index) => {\n      /**\n       * Skip every second\n       */\n      if (index % 2 === 1){\n        return;\n      }\n\n      const dt = new Date(date);\n      const dateEl = Dom.make('time');\n      dateEl.textContent = dt.toLocaleDateString('en-US', {\n        day: 'numeric',\n        month: 'short'\n      });\n\n      this.legend.appendChild(dateEl)\n    });\n\n    Dom.insertAfter(this.canvas, this.legend);\n  }\n\n  /**\n   * Scale left legend\n   * @param {number} scaling\n   */\n  scaleLines(scaling){\n    this.pathsList.forEach( path => {\n      path.scaleX(scaling);\n    });\n\n    const newWidth = this.initialWidth * scaling;\n    this.canvas.style.width = newWidth + 'px';\n\n    const canFit = Math.round(newWidth / this.stepX);\n    const nowFit = Math.round(this.initialWidth / this.stepX);\n    const fitability = Math.floor(nowFit / canFit + 0.9);\n\n    if (fitability % 2 === 1){\n      this.legend.classList.add(`skip-${fitability}`);\n    }\n\n    this.legend.classList.toggle('skip-odd', nowFit / canFit > 1.7);\n    this.legend.classList.toggle('skip-third', nowFit / canFit > 3.2);\n    this.legend.classList.toggle('skip-fifth', nowFit / canFit > 5.5);\n    this.legend.classList.toggle('skip-seventh', nowFit / canFit > 7);\n    this.legend.classList.toggle('skip-ninth', nowFit / canFit > 9.2);\n    this.legend.classList.toggle('skip-eleventh', nowFit / canFit > 14);\n  }\n\n  get step(){\n    return this.stepX;\n  }\n\n  /**\n   * Scale path on OY\n   * @param {number} newMax - new max value\n   */\n  scaleToMaxPoint(newMax){\n    let scaling = this.maxPoint / newMax * 0.8;\n\n    this.pathsList.forEach( path => {\n      path.scaleY(scaling);\n    });\n\n    /**\n     * Rerender grid if it was rendered before\n     */\n    if (this.grid){\n      this.renderGrid(newMax * 1.2, true);\n    }\n  }\n\n  checkPathVisibility(name){\n    return !this.paths[name].isHidden;\n  }\n\n  togglePathVisibility(name){\n    this.paths[name].toggleVisibility();\n  }\n}","import * as Dom from '../utils/dom.js';\nimport * as Event from '../utils/event.js';\nimport debounce from '../utils/debounce.js';\nimport Graph from './graph.js';\n\n\n/**\n * Module for working with Chart Mini map\n * - Render UI\n * - Render graphs\n * - Scaling\n * - Scrolling\n */\nexport default class Minimap {\n  constructor(modules){\n    this.modules = modules;\n    /**\n     * @param {State} state\n     */\n    this.state = modules.state;\n    this.nodes = {\n      wrapper: undefined,\n      canvas: undefined,\n\n      leftZone: undefined,\n      leftZoneScaler: undefined,\n      rightZone: undefined,\n      rightZoneScaler: undefined,\n    };\n\n    this.wrapperWidthCached = undefined;\n    this.viewportWidth = 100;\n    this.viewportWidthInitial = 100;\n    this.viewportOffsetLeft = 0;\n\n    /**\n     * Remember width on touch start\n     */\n    this.viewportWidthBeforeDrag = undefined;\n\n    /**\n     * Clicked pageX\n     */\n    this.moveStartX = undefined;\n\n    /**\n     * Clicked layerX\n     */\n    this.wrapperLeftCoord = undefined;\n\n    /**\n     * Indicator that viewport zone is dragged\n     */\n    this.viewportPressed = false;\n\n    /**\n     * Indicator that left scaler zone is dragged\n     */\n    this.leftScalerClicked = false;\n\n    /**\n     * Indicator that right scaler zone is dragged\n     */\n    this.rightScalerClicked = false;\n\n    /**\n     * Scale debounce\n     */\n    this.scaleDebounce = undefined;\n\n    this.graph = new Graph(this.state, {\n      stroke: 1\n    });\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-minimap',\n      leftZone: 'tg-minimap__left',\n      leftZoneScaler: 'tg-minimap__left-scaler',\n      rightZone: 'tg-minimap__right',\n      rightZoneScaler: 'tg-minimap__right-scaler',\n    }\n  }\n\n  /**\n   * Prepares minimap UI\n   * @return {Element}\n   */\n  renderUi(){\n    this.nodes.wrapper = Dom.make('div', Minimap.CSS.wrapper);\n    this.nodes.leftZone = Dom.make('div', Minimap.CSS.leftZone);\n    this.nodes.rightZone = Dom.make('div', Minimap.CSS.rightZone);\n    this.nodes.leftZoneScaler = Dom.make('div', Minimap.CSS.leftZoneScaler);\n    this.nodes.rightZoneScaler = Dom.make('div', Minimap.CSS.rightZoneScaler);\n\n    this.nodes.leftZone.appendChild(this.nodes.leftZoneScaler);\n    this.nodes.rightZone.appendChild(this.nodes.rightZoneScaler);\n\n    this.nodes.wrapper.appendChild(this.nodes.leftZone);\n    this.nodes.wrapper.appendChild(this.nodes.rightZone);\n\n    this.bindEvents();\n\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Fill UI with chart and set initial Position\n   */\n  renderMap(){\n    this.nodes.canvas = this.graph.renderCanvas({\n      width: this.nodes.wrapper.offsetWidth,\n      height: this.nodes.wrapper.offsetHeight\n    });\n\n    this.state.linesAvailable.forEach( name => {\n      this.graph.renderLine(name);\n    });\n\n    this.setInitialPosition();\n\n    this.nodes.wrapper.appendChild(this.nodes.canvas);\n  }\n\n  /**\n   * Return width of a mini map\n   * @return {number}\n   */\n  get wrapperWidth(){\n    return this.wrapperWidthCached || this.nodes.wrapper.offsetWidth;\n  }\n\n  /**\n   * Compute current minimap width\n   * @return {number}\n   */\n  get width(){\n    return this.wrapperWidth - parseInt(this.nodes.leftZone.style.width, 10) - parseInt(this.nodes.rightZone.style.width, 10);\n  }\n\n  /**\n   * Set new with to the minimap's viewport\n   * @param value\n   */\n  set width(value){\n    const scrollDistance = this.modules.chart.scrollDistance;\n\n    this.nodes.leftZone.style.width = scrollDistance + 'px';\n    this.nodes.rightZone.style.width = this.wrapperWidth - scrollDistance - value + 'px';\n    this.viewportWidth = value;\n  }\n\n  /**\n   * Initial width and offset\n   */\n  setInitialPosition(){\n    let rect = this.nodes.wrapper.getBoundingClientRect();\n    this.wrapperWidthCached = rect.width;\n    this.wrapperLeftCoord = rect.left;\n\n    const chartToViewportRatio = this.modules.chart.viewportWidth / this.modules.chart.width;\n    this.width = this.wrapperWidth * chartToViewportRatio;\n    this.viewportWidthInitial = this.viewportWidthBeforeDrag = this.width;\n    // this.viewportOffsetLeft = this.wrapperWidth - this.viewportWidthInitial;\n    this.viewportOffsetLeft = 0;\n    this.moveViewport(this.viewportOffsetLeft);\n    this.syncScrollWithChart();\n  }\n\n  /**\n   * Current scroll value\n   * @return {number}\n   */\n  get scrolledValue(){\n    return parseInt(this.nodes.leftZone.style.width, 10);\n  }\n\n  /**\n   * Value of left zone width minimum\n   */\n  get leftZoneMinimumWidth(){\n    return 0;\n  }\n\n  /**\n   * Value of left zone width maximum\n   */\n  get leftZoneMaximumWidth(){\n    return this.wrapperWidth - this.viewportWidthInitial - parseInt(this.nodes.rightZone.style.width);\n  }\n\n  /**\n   * Value of right zone width minimum\n   */\n  get rightZoneMinimumWidth(){\n    return this.viewportWidthInitial;\n  }\n\n  /**\n   * Value of right zone width maximum\n   */\n  get rightZoneMaximumWidth(){\n    return this.wrapperWidth - this.viewportWidthInitial - this.scrolledValue;\n  }\n\n  /**\n   * Moves viewport from left for passed value\n   * @param {string} offsetLeft\n   */\n  moveViewport(offsetLeft){\n    const width = this.width;\n    const maxLeft = this.wrapperWidth - width;\n    const minLeft = this.leftZoneMinimumWidth;\n\n    let newLeft = this.viewportOffsetLeft + offsetLeft;\n\n    if (newLeft < minLeft){\n      newLeft = minLeft;\n    } else if (newLeft > maxLeft){\n      newLeft = maxLeft;\n    }\n    this.nodes.leftZone.style.width = newLeft + 'px';\n    this.nodes.rightZone.style.width = this.wrapperWidth - this.viewportWidthBeforeDrag - newLeft;\n  }\n\n  bindEvents(){\n    this.nodes.wrapper.addEventListener('mousedown', (event) => {\n      this.viewportMousedown(event);\n    });\n\n    document.body.addEventListener('mousemove', (event) => {\n      this.viewportMousemove(event);\n    });\n\n    document.body.addEventListener('mouseup', (event) => {\n      this.viewportMouseup(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchstart', (event) => {\n      this.viewportMousedown(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchmove', (event) => {\n      this.viewportMousemove(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchend', (event) => {\n      this.viewportMouseup(event);\n    });\n  }\n\n  /**\n   * Viewport under finger\n   * @param {MouseEvent|TouchEvent} event\n   */\n  viewportMousedown(event){\n    const {target} = event;\n\n    event.preventDefault();\n\n    const leftScalerClicked = !!target.closest(`.${Minimap.CSS.leftZoneScaler}`);\n    const rightScalerClicked = !!target.closest(`.${Minimap.CSS.rightZoneScaler}`);\n\n    this.viewportWidthBeforeDrag = this.width;\n    this.moveStartX = Event.getPageX(event);\n\n    if (leftScalerClicked || rightScalerClicked){\n      this.leftScalerClicked = leftScalerClicked;\n      this.rightScalerClicked = rightScalerClicked;\n      this.viewportPressed = false;\n      return;\n    }\n\n\n    this.viewportPressed = true;\n  }\n\n  /**\n   * Viewport dragged\n   * @param {MouseEvent} event\n   */\n  viewportMousemove(event){\n    if (this.viewportPressed){\n      this.viewportDragged(event);\n    } else if (this.leftScalerClicked){\n      this.scalerDragged(event, 'left');\n    } else if (this.rightScalerClicked){\n      this.scalerDragged(event, 'right');\n    }\n  }\n\n  viewportMouseup(){\n    if (this.viewportPressed){\n      this.finishSliding();\n    } else if (this.leftScalerClicked){\n      this.finishLeftScaling();\n    } else if (this.rightScalerClicked){\n      this.finishRightScaling();\n    }\n  }\n\n  finishSliding(){\n    this.viewportPressed = false;\n    this.viewportOffsetLeft = this.scrolledValue;\n  }\n\n  finishLeftScaling(){\n    this.leftScalerClicked = false;\n    this.viewportOffsetLeft = this.scrolledValue;\n  }\n\n  finishRightScaling(){\n    this.rightScalerClicked = false;\n    this.viewportOffsetLeft = this.scrolledValue;\n  }\n\n  /**\n   * @param {MouseEvent} event\n   */\n  viewportDragged(event){\n    let delta = Event.getPageX(event) - this.moveStartX;\n\n    this.moveViewport(delta);\n    this.syncScrollWithChart();\n\n    this.modules.chart.fitToMax(true);\n  }\n\n  syncScrollWithChart(){\n    /**\n     * How many percents of mini-map is scrolled\n     */\n    const minimapScrolledPortion = this.scrolledValue / this.wrapperWidth;\n    const chartScroll = minimapScrolledPortion * this.modules.chart.width;\n\n    this.modules.chart.scroll(chartScroll);\n  }\n\n  /**\n   * Viewport side-scaler is moved\n   * @param {MouseEvent|TouchEvent} event\n   * @param {string} side — 'left' or 'right'\n   */\n  scalerDragged(event, side){\n    let pageX = Event.getPageX(event);\n    let delta = pageX - this.moveStartX;\n\n    if (!delta){\n      return;\n    }\n\n    let newWidth;\n\n    if (side === 'left'){\n      delta = delta * -1;\n      newWidth = this.viewportOffsetLeft - delta;\n\n      if (newWidth > this.leftZoneMaximumWidth) {\n        return;\n      }\n\n      this.nodes.leftZone.style.width = newWidth + 'px';\n\n    } else {\n      newWidth = this.wrapperWidth - this.viewportOffsetLeft - (this.viewportWidthBeforeDrag + delta);\n\n      if (newWidth > this.rightZoneMaximumWidth){\n        return;\n      }\n\n      this.nodes.rightZone.style.width = newWidth + 'px';\n    }\n\n    this.syncScrollWithChart();\n\n    const scaling = this.viewportWidthInitial / this.width ;\n\n\n    this.modules.chart.scale(scaling);\n\n    if (this.scaleDebounce){\n      clearTimeout(this.scaleDebounce);\n    }\n\n    this.scaleDebounce = setTimeout(() => {\n      this.modules.chart.fitToMax(true);\n    }, 30)\n  }\n\n  /**\n   * Toggle path visibility\n   * @param {string} name - graph name\n   */\n  togglePath(name){\n    this.graph.togglePathVisibility(name);\n    this.fitToMax();\n  }\n\n  /**\n   * Upscale or downscale graph to fit visible points\n   */\n  fitToMax(){\n    const maxVisiblePoint = Math.max(...this.state.linesAvailable.filter(line => this.graph.checkPathVisibility(line)).map(line => {\n      return Math.max(...this.state.getLinePoints(line));\n    }));\n\n    this.graph.scaleToMaxPoint(maxVisiblePoint);\n  }\n}","import * as Dom from '../utils/dom.js';\nimport * as Numbers from '../utils/numbers';\n\nexport default class Tooltip {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper:  undefined,\n      title: undefined,\n      values: undefined\n    }\n  }\n\n  /**\n   * CSS map\n   * @return {{wrapper: string, title: string, values: string, value: string}}\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-tooltip',\n      showed: 'tg-tooltip--showed',\n      title: 'tg-tooltip__title',\n      values: 'tg-tooltip__values',\n      value: 'tg-tooltip__values-item',\n    }\n  }\n\n  render(){\n    this.nodes.wrapper = Dom.make('div', Tooltip.CSS.wrapper);\n    this.nodes.title = Dom.make('div', Tooltip.CSS.title);\n    this.nodes.values = Dom.make('div', Tooltip.CSS.values);\n\n    this.nodes.wrapper.appendChild(this.nodes.title);\n    this.nodes.wrapper.appendChild(this.nodes.values);\n\n    return this.nodes.wrapper;\n  }\n\n  show(){\n    this.nodes.wrapper.classList.add(Tooltip.CSS.showed);\n  }\n\n  hide(){\n    this.nodes.wrapper.classList.remove(Tooltip.CSS.showed);\n  }\n\n  move(lineLeftCoord){\n    let offsetLeft = -25;\n    const tooltipWidth = this.nodes.wrapper.offsetWidth;\n\n    if (lineLeftCoord > this.modules.chart.viewportWidth - tooltipWidth / 1.3){\n      offsetLeft = -1.3 * tooltipWidth;\n    } else if (lineLeftCoord > this.modules.chart.viewportWidth - tooltipWidth ){\n      offsetLeft = -0.8 * tooltipWidth;\n    } else if (lineLeftCoord < 45){\n      offsetLeft = 20;\n    }\n\n    this.nodes.wrapper.style.left = `${lineLeftCoord + offsetLeft}px`;\n  }\n\n  clear(){\n    this.nodes.title.textContent = '';\n    this.nodes.values.innerHTML = '';\n  }\n\n  /**\n   * Render values of current hovered points\n   * @param {{name: string, value: number}[]} values\n   */\n  set values(values){\n    this.clear();\n\n    values.forEach( ({name, value}) => {\n      const item = Dom.make('div', Tooltip.CSS.value);\n      const color = this.modules.state.colors[name];\n      const title = this.modules.state.names[name];\n\n\n      item.innerHTML = `<b>${Numbers.beautify(value)}</b>${title}`;\n      item.style.color = color;\n\n      this.nodes.values.appendChild(item);\n    })\n  }\n\n  set title(string){\n    this.nodes.title.innerHTML = string;\n  }\n}","import * as Dom from '../utils/dom.js';\nimport Graph from './graph.js';\nimport Tooltip from \"./tooltip\";\nimport * as Event from '../utils/event.js';\n\n/**\n * Module for working with main Chart zone\n * - Render UI\n * - Render axes\n * - Render graphs\n * - Toggle lines visibility\n */\nexport default class Chart {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    /**\n     * @param {State} state\n     */\n    this.state = modules.state;\n    this.nodes = {\n      wrapper: undefined,\n      viewport: undefined,\n      canvas: undefined,\n      cursorLine: undefined\n    };\n\n    this.tooltip = new Tooltip(this.modules);\n    this.graph = new Graph(this.state, {\n      stroke: 2.5\n    });\n\n    this.wrapperLeftCoord = undefined;\n    this.scaling = 1;\n    this.scrollValue = 0;\n\n    /**\n     * Any properties can be cached here\n     * @type {{}}\n     */\n    this.cache = {};\n  }\n\n  /**\n   * CSS map\n   * @return {{wrapper: string, viewport: string, cursorLine: string}}\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-chart',\n      viewport: 'tg-chart__viewport',\n      cursorLine: 'tg-chart__cursor-line',\n      cursorLineShowed: 'tg-chart__cursor-line--showed',\n    }\n  }\n\n  /**\n   * Return current scroll distance\n   * @return {number}\n   */\n  get scrollDistance() {\n    return this.scrollValue * this.scaling;\n  }\n\n  /**\n   * Return current scaling value\n   * @return {number|*}\n   */\n  get scalingValue(){\n    return this.scaling;\n  }\n\n  /**\n   * Prepare UI\n   * @return {Element}\n   */\n  renderUi(){\n    this.nodes.wrapper = Dom.make('div', Chart.CSS.wrapper);\n    this.nodes.viewport = Dom.make('div', Chart.CSS.viewport);\n    this.nodes.cursorLine = Dom.make('div', Chart.CSS.cursorLine);\n\n    this.nodes.wrapper.appendChild(this.nodes.viewport);\n    this.nodes.wrapper.appendChild(this.nodes.cursorLine);\n\n    this.nodes.wrapper.appendChild(this.tooltip.render());\n\n    this.bindEvents();\n\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Renders charts\n   */\n  renderCharts(){\n    this.calculateWrapperCoords();\n\n    /**\n     * @todo pass height through the initial settings\n     */\n    this.nodes.canvas = this.graph.renderCanvas({\n      height: 400\n    });\n    this.nodes.viewport.appendChild(this.nodes.canvas);\n\n    const dates = this.state.dates;\n\n    this.state.linesAvailable.forEach( name => {\n      this.graph.renderLine(name);\n    });\n\n    this.graph.renderGrid();\n    this.graph.renderLegend(dates);\n  }\n\n  /**\n   * Total chart width\n   * @return {number}\n   */\n  get width(){\n    return this.graph.width;\n  }\n\n  /**\n   * Visible viewport width\n   * @return {number}\n   */\n  get viewportWidth(){\n    if (this.cache.viewportWidth){\n      return this.cache.viewportWidth;\n    }\n\n    this.cache.viewportWidth = this.nodes.wrapper.offsetWidth;\n    return this.cache.viewportWidth;\n  }\n\n  /**\n   * Visible viewport height\n   * @return {number}\n   */\n  get viewportHeight(){\n    if (this.cache.viewportHeight){\n      return this.cache.viewportHeight;\n    }\n\n    this.cache.viewportHeight = this.nodes.wrapper.offsetHeight;\n    return this.cache.viewportHeight;\n  }\n\n  /**\n   * Perform scroll\n   * @param position\n   */\n  scroll(position){\n    let newLeft = position * -1;\n    this.nodes.viewport.style.transform = `translateX(${newLeft}px)`;\n    this.scrollValue = newLeft;\n    this.tooltip.hide();\n    this.nodes.cursorLine.classList.remove(Chart.CSS.cursorLineShowed);\n  }\n\n  /**\n   * Perform scaling\n   * @param {number} scaling\n   */\n  scale(scaling){\n    this.graph.scaleLines(scaling);\n\n    this.scaling = scaling;\n  }\n\n  /**\n   * Left visible point\n   * @return {number}\n   */\n  get leftPointIndex(){\n    return Math.round(this.scrollValue * -1/ this.graph.step / this.scaling);\n  }\n\n  /**\n   * Filter to skip hidden line\n   * @param {string} line - name of the graph\n   * @return {boolean}\n   */\n  notHiddenGraph(line){\n    return this.graph.checkPathVisibility(line);\n  }\n\n  /**\n   * Upscale or downscale graph to fit visible points\n   */\n  fitToMax(){\n    const stepX = this.graph.step;\n    const pointsVisible = Math.round(this.viewportWidth / stepX / this.scaling);\n    const maxVisiblePoint = Math.max(...this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).map(line => {\n      let slice = this.state.getPointsSlice(line, this.leftPointIndex, pointsVisible);\n      return Math.max(...slice);\n    }));\n\n    this.graph.scaleToMaxPoint(maxVisiblePoint);\n  }\n\n  /**\n   * Store wrapper rectangle data\n   */\n  calculateWrapperCoords(){\n    let rect = this.nodes.wrapper.getBoundingClientRect();\n\n    this.wrapperLeftCoord = rect.left;\n  }\n\n  bindEvents(){\n    this.nodes.wrapper.addEventListener('mousemove', (event) => {\n      this.mouseMove(event);\n    });\n\n    this.nodes.wrapper.addEventListener('mouseleave', (event) => {\n      this.mouseLeave(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchmove', (event) => {\n      this.mouseMove(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchcancel', (event) => {\n      this.mouseLeave(event);\n    });\n  }\n\n  /**\n   * Shows line with Tooltip\n   * @param {MouseEvent|TouchEvent} event\n   */\n  mouseMove(event){\n    let x = Event.getPageX(event);\n    let viewportX = x - this.wrapperLeftCoord ;\n    let scrollOffset = this.scrollValue % this.graph.stepX;\n    let pointIndex = Math.round(viewportX / this.graph.stepX / this.scaling);\n    let hoveredPointIndex = pointIndex + this.leftPointIndex;\n\n    if (Math.abs(scrollOffset) > (this.graph.stepX / 2) ){\n      pointIndex = pointIndex + 1;\n    }\n\n    // let firstStepOffset = this.graph.stepX - Math.abs(scrollOffset);\n    let newLeft = (pointIndex * this.graph.stepX + scrollOffset) * this.scaling;\n\n    // console.log('scroll offset %o | step %o | index %o | x %o | drawn at %o | first step offset %o | left index %o', scrollOffset, this.graph.stepX, pointIndex, viewportX, newLeft, firstStepOffset, this.leftPointIndex);\n\n    this.tooltip.show();\n\n    this.nodes.cursorLine.style.left = `${newLeft}px`;\n    this.nodes.cursorLine.classList.add(Chart.CSS.cursorLineShowed);\n\n    const values = this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).map( line => {\n      return {\n        name: line,\n        value: this.state.getLinePoints(line)[hoveredPointIndex]\n      }\n    });\n\n    const date = this.state.dates[hoveredPointIndex];\n\n    /**\n     * Skip bounding empty positions\n     */\n    if (!date){\n      return;\n    }\n\n    this.tooltip.values = values;\n    this.tooltip.move(newLeft);\n    this.tooltip.title = (new Date(date)).toLocaleDateString('en-US', {\n      day: 'numeric',\n      month: 'short',\n      weekday: 'short'\n    });\n  }\n\n  mouseLeave(){\n    this.tooltip.hide();\n    this.nodes.cursorLine.classList.remove(Chart.CSS.cursorLineShowed);\n  }\n\n  /**\n   * Toggle path visibility\n   * @param {string} name - graph name\n   */\n  togglePath(name){\n    this.graph.togglePathVisibility(name);\n    this.fitToMax();\n  }\n}","import * as Dom from '../utils/dom.js';\n\nexport default class Legend {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper: undefined,\n    };\n\n    this.buttons = {};\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-legend',\n      item: 'tg-legend__item',\n      itemEnabled: 'tg-legend__item--enabled',\n      checkbox: 'tg-legend__checkbox',\n    }\n  }\n\n  /**\n   * Show graphs togglers\n   * @return {Element}\n   */\n  render(){\n    this.nodes.wrapper = Dom.make('div', Legend.CSS.wrapper);\n\n    /**\n     * Object with names -> array with names\n     */\n    const namesArray = Object.entries(this.modules.state.names).map(([name, title]) => {\n      return {name, title}\n    });\n\n    namesArray.forEach(({name, title}) => {\n      let item = Dom.make('div', [Legend.CSS.item, Legend.CSS.itemEnabled]),\n        checkbox = Dom.make('span', Legend.CSS.checkbox);\n\n      checkbox.style.borderColor = this.modules.state.colors[name];\n      checkbox.style.backgroundColor = this.modules.state.colors[name];\n\n      item.appendChild(checkbox);\n      item.appendChild(document.createTextNode(title));\n\n      this.buttons[name] = item;\n\n      item.addEventListener('click', () => {\n        this.itemClicked(name);\n      });\n\n      this.nodes.wrapper.appendChild(item);\n    });\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Click handler for togglers\n   * @param {string} name - graph name\n   */\n  itemClicked(name){\n    this.modules.chart.togglePath(name);\n    this.modules.minimap.togglePath(name);\n\n    this.buttons[name].classList.toggle(Legend.CSS.itemEnabled);\n\n    const checkbox = this.buttons[name].querySelector(`.${Legend.CSS.checkbox}`);\n\n    /**\n     * @todo add animation\n     */\n    if (this.buttons[name].classList.contains(Legend.CSS.itemEnabled)){\n      checkbox.style.boxShadow = `inset 0 0 0 10px ${this.modules.state.colors[name]}`;\n    } else {\n      checkbox.style.boxShadow = 'none';\n      checkbox.style.backgroundColor = 'transparent';\n    }\n  }\n}\n","import State from './modules/state';\nimport Minimap from './modules/minimap.js';\nimport Chart from './modules/chart.js';\nimport Legend from './modules/legend.js';\n\n/**\n * @typedef {object} ChartData\n * @property {array} columns – List of all data columns in the chart.\n *                             0 - position (\"x\", \"y0\", \"y1\")\n *                             1+ - values\n *                             \"x\" values are UNIX timestamps in milliseconds.\n * @property {{x, y0, y1}} types – Chart types for each of the columns.\n *                                 Supported values:\n *                                 \"line\" (line on the graph with linear interpolation),\n *                                 \"x\" (x axis values for each of the charts at the corresponding positions).\n * @property {{y0: string, y1: string}} colors – Color for each line in 6-hex-digit format (e.g. \"#AAAAAA\").\n * @property {{y0: string, y1: string}} names – Names for each line.\n */\n\nexport default class Telegraph {\n  /**\n   * Main entry constructor\n   * @param {string} holderId - where to append a Chart\n   * @param {ChartData} inputData - chart data\n   */\n  constructor({holderId, inputData}){\n    this.holder = document.getElementById(holderId);\n\n    /**\n     * Module that stores all main app state values\n     */\n    this.state = new State(inputData);\n\n    /**\n     * Module for mini map\n     */\n    this.minimap = new Minimap(this);\n\n    /**\n     * Working with main chart zone\n     */\n    this.chart = new Chart(this);\n\n    /**\n     * Working with legend items\n     */\n    this.legend = new Legend(this);\n\n    /**\n     * Create base UI elements\n     */\n    this.prepareUi();\n\n    /**\n     * Render chart and minimap\n     */\n    this.chart.renderCharts();\n    this.minimap.renderMap()\n  }\n\n  /**\n   * CSS classes map\n   * @return {{nightModeEnabled: string}}\n   */\n  static get CSS(){\n    return {\n      nightModeEnabled : 'tg--night-mode'\n    }\n  }\n\n  /**\n   * Create base app UI\n   */\n  prepareUi(){\n    this.holder.appendChild(this.chart.renderUi());\n    this.holder.appendChild(this.minimap.renderUi());\n    this.holder.appendChild(this.legend.render());\n  }\n\n  /**\n   * @public\n   * Toggles night mode\n   */\n  toggleNightMode(){\n    this.holder.classList.toggle(Telegraph.CSS.nightModeEnabled);\n  }\n}"],"sourceRoot":""}