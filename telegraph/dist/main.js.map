{"version":3,"sources":["webpack://Telegraph/webpack/bootstrap","webpack://Telegraph/./src/modules/state.js","webpack://Telegraph/./src/utils/dom.js","webpack://Telegraph/./src/utils/numbers.js","webpack://Telegraph/./src/modules/path.js","webpack://Telegraph/./src/modules/graph.js","webpack://Telegraph/./src/modules/minimap.js","webpack://Telegraph/./src/modules/tooltip.js","webpack://Telegraph/./src/modules/chart.js","webpack://Telegraph/./src/modules/legend.js","webpack://Telegraph/./src/telegraph.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","State","[object Object]","chartsData","this","columns","colors","names","types","dates","slice","linesAvailable","keys","daysCount","length","lineName","getColumnByName","findIndex","column","from","count","getLinePoints","max","maxPerLines","map","Math","colorsList","entries","namesList","make","tagName","classNames","attributes","el","includes","document","createElementNS","createElement","Array","isArray","classList","add","className","attrName","setAttribute","beautify","number","thousands","floor","left","path_Path","color","svg","stroke","stepX","opacity","kY","canvasHeight","prevX","path","stroke-width","fill","stroke-linecap","vector-effect","pathData","CSS","graphHidden","parseInt","style","height","canvasWidth","offsetWidth","val","round","x","y","appendChild","animate","text","textAnchor","dominant-baseline","createTextNode","fontSize","getTotalLength","transition","WebkitTransition","strokeDasharray","strokeDashoffset","getBoundingClientRect","setTimeout","removeProperty","scaling","oldTransform","transform","replace","isHidden","contains","toggle","graph_Graph","state","canvas","undefined","legend","grid","stepY","strokeWidth","initialWidth","maxPoint","paths","gridSection","pathsList","width","setCanvasWidth","computeSteps","ceil","reverse","find","step","values","getLineColor","leftPoint","moveTo","forEach","stepTo","render","forceMax","remove","linesCount","j","line","bottom","textContent","target","element","parentNode","insertBefore","date","index","dt","Date","dateEl","toLocaleDateString","day","month","nextSibling","scaleX","newWidth","canFit","nowFit","fitability","newMax","scaleY","renderGrid","toggleVisibility","minimap_Minimap","nodes","wrapper","leftZone","leftZoneScaler","rightZone","rightZoneScaler","wrapperWidthCached","viewportWidth","viewportWidthInitial","viewportOffsetLeft","moveStartX","moveStartLayerX","wrapperLeftCoord","viewportPressed","leftScalerClicked","rightScalerClicked","graph","bindEvents","renderCanvas","offsetHeight","renderLine","setInitialPosition","wrapperWidth","scrollDistance","chart","rect","chartToViewportRatio","moveViewport","syncScrollWithChart","scrolledValue","offsetLeft","maxLeft","newLeft","addEventListener","event","viewportMousedown","viewportMousemove","viewportMouseleave","viewportMouseup","preventDefault","closest","touches","pageX","layerX","viewportDragged","scalerDragged","finishSliding","finishLeftScaling","finishRightScaling","delta","fitToMax","chartScroll","scroll","side","pullDirection","scale","tooltip_Tooltip","title","showed","lineLeftCoord","tooltipWidth","innerHTML","clear","item","string","chart_Chart","viewport","cursorLine","tooltip","scrollValue","scalingValue","calculateWrapperCoords","renderLegend","viewportHeight","position","scaleLines","leftPointIndex","checkPathVisibility","pointsVisible","maxVisiblePoint","filter","notHiddenGraph","getPointsSlice","scaleToMaxPoint","mouseMove","mouseLeave","viewportX","pointIndex","show","scrollOffset","hoveredPointIndex","move","weekday","hide","togglePathVisibility","legend_Legend","buttons","itemEnabled","checkbox","borderColor","backgroundColor","itemClicked","togglePath","querySelector","__webpack_exports__","telegraph_Telegraph","holderId","inputData","holder","getElementById","minimap","prepareUi","renderCharts","renderMap","renderUi"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * This class stores the sate of application\n * @todo add cache to all getters\n */\nexport default class State {\n  /**\n   * @param {ChartData} chartsData - input data\n   */\n  constructor(chartsData){\n    this.columns = chartsData.columns;\n    this.colors = chartsData.colors;\n    this.names = chartsData.names;\n    this.types = chartsData.types;\n  }\n\n  /**\n   * Column with dates is 0-index column, so shift it\n   * First element in arrays is column name (\"x\") so slice it\n   * @return {number[]} - array of dates in milliseconds\n   */\n  get dates(){\n    return this.columns[0].slice(1);\n  }\n\n  /**\n   * Return available line names\n   * @return {string[]} - array of graph names\n   */\n  get linesAvailable(){\n    return Object.keys(this.names);\n  }\n\n  /**\n   * Returns numbers of days at the input data\n   * @return {number}\n   */\n  get daysCount(){\n    return this.columns[0].length - 1; // -1 because the first element is column type (\"x\")\n  }\n\n  /**\n   * Returns values of line by line name\n   * @param {string} lineName - \"y0\", \"y1\" etc\n   * @return {number[]}\n   */\n  getLinePoints(lineName){\n    return this.getColumnByName(lineName).slice(1); // slice 0-element because it is a column name\n  }\n\n  /**\n   * Return column by name\n   * @param {string} name - \"y0\", \"y1\" etc\n   * @return {array}\n   */\n  getColumnByName(name){\n    return this.columns[this.columns.findIndex(column => column[0] === name)];\n  }\n\n  /**\n   * Return N points from passed position\n   * @param {string} lineName - \"y0\", \"y1\", ...etc\n   * @param {number} from - start position\n   * @param {number} count - how many items requested\n   * @return {number[]}\n   */\n  getPointsSlice(lineName, from, count){\n    return this.getLinePoints(lineName).slice(from, from + count);\n  }\n\n  /**\n   * Returns color of line by line name\n   * @param {string} lineName - \"y0\", \"y1\" etc\n   * @return {string} - hex color like \"#333333\"\n   */\n  getLineColor(lineName){\n    return this.colors[lineName];\n  }\n\n  /**\n   * Return maximum value from all charts\n   * @return {number}\n   */\n  get max(){\n    const maxPerLines = this.linesAvailable.map( name => {\n      return Math.max(...this.getLinePoints(name));\n    });\n\n    return Math.max(...maxPerLines);\n  }\n\n  /**\n   * Array of available colors\n   * @return {string[]}\n   */\n  get colorsList(){\n    return Object.entries(this.colors).map(([name, value]) => value);\n  }\n\n  /**\n   * Array of available chart names\n   * @return {string[]}\n   */\n  get namesList(){\n    return Object.entries(this.names).map(([name, value]) => value);\n  }\n}","/**\n * Create HTML element\n * @param {string} tagName - HTML element tag name\n * @param {string[]|string} classNames - array of CSS classes\n * @param attributes - any attributes\n * @return {HTMLElement}\n */\nexport function make(tagName, classNames = undefined, attributes = {}) {\n  const svgNamespace = 'http://www.w3.org/2000/svg';\n  const svgElements = ['svg', 'path', 'rect', 'circle', 'text'];\n  const isSvg = svgElements.includes(tagName);\n  const el = !isSvg ? document.createElement(tagName) : document.createElementNS(svgNamespace, tagName);\n\n  if (Array.isArray(classNames) && classNames.length) {\n    el.classList.add(...classNames);\n  } else if (classNames) {\n    el.className = classNames;\n  }\n\n  if (attributes && Object.keys(attributes).length) {\n    for (let attrName in attributes) {\n      if (attributes.hasOwnProperty(attrName)) {\n        el.setAttribute(attrName, attributes[attrName]);\n      }\n    }\n  }\n\n  return el;\n}\n\n/**\n * Inserts one element after another\n */\nexport function insertAfter(target, element) {\n  target.parentNode.insertBefore(element, target.nextSibling);\n}\n\n/**\n * Insert one element before another\n */\nexport function insertBefore(target, element) {\n  target.parentNode.insertBefore(element, target);\n}","export function beautify(number) {\n  if (number < 1000) {\n    return number\n  } else if (number < 10000){\n      let thousands = Math.floor(number / 1000);\n      let left = number - thousands * 1000;\n\n      if (left > 100){\n        return thousands + ' ' + left;\n      } else if (left > 10) {\n        return thousands + ' 0' + left;\n      } else {\n        return thousands + ' 00' + left;\n      }\n  } else if (number < 1000000) {\n      return Math.floor(number / 1000) + 'k';\n  } else {\n    return Math.floor(number / 1000000) + 'M';\n  }\n}","import * as Dom from \"../utils/dom\";\n\n/**\n * Helper for creating an SVG path\n */\nexport default class Path {\n  constructor({color, svg, max, stroke, stepX, opacity = 1}){\n    this.svg = svg;\n    this.kY = max !== 0 ? this.canvasHeight / max : 1;\n    this.stepX = stepX;\n    this.prevX = 0;\n\n    this.path = Dom.make('path', null, {\n      'stroke-width' : stroke,\n      stroke : color,\n      fill : 'transparent',\n      'stroke-linecap' : 'round',\n      'vector-effect': 'non-scaling-stroke',\n      opacity\n    });\n\n    this.pathData = '';\n  }\n\n  static get CSS(){\n    return {\n      graphHidden: 'tg-graph--hidden'\n    }\n  }\n\n  /**\n   * @todo get offsetHeight instead of style.height\n   * @todo cache value\n   * @return {number}\n   */\n  get canvasHeight(){\n    return parseInt(this.svg.style.height, 10);\n  }\n\n  get canvasWidth(){\n    return this.svg.offsetWidth;\n  }\n\n  /**\n   * Compute Y value with scaling\n   */\n  y(val){\n    return Math.round(this.canvasHeight - val * this.kY);\n  }\n\n  /**\n   * Compute X value with scaling\n   */\n  x(val){\n    return val;\n  }\n\n  /**\n   * Go to passed coords\n   * @param {number} x\n   * @param {number} y\n   */\n  moveTo(x, y){\n    this.pathData += `M ${this.x(x)} ${this.y(y)}`;\n  }\n\n  /**\n   * Continue line to the next value\n   * @param {number} y\n   */\n  stepTo(y){\n    this.prevX = this.prevX + this.stepX;\n    this.pathData += ` L ${this.x(this.prevX)} ${this.y(y)}`;\n  }\n\n  /**\n   * Create a new line with x and y\n   * @param {number} x\n   * @param {number} y\n   */\n  lineTo(x, y){\n    this.pathData += ` L ${this.x(x)} ${this.y(y)}`;\n  }\n\n  /**\n   * Append a line\n   */\n  render(){\n    this.path.setAttribute('d', this.pathData);\n    this.svg.appendChild(this.path);\n    this.animate();\n  }\n\n  /**\n   * Drop text to passed point\n   * @param value\n   */\n  dropText(value){\n    let text = Dom.make('text', null, {\n      x: this.prevX + this.stepX,\n      y: this.y(value),\n      fill: '#cccccc',\n      textAnchor: 'left',\n      'dominant-baseline': 'use-script'\n    })\n\n    text.appendChild(document.createTextNode(value));\n    text.style.fontSize = 13 + 'px';\n\n    this.svg.appendChild(text);\n  }\n\n  animate(){\n    const speed = 2000;\n    const length = this.path.getTotalLength();\n\n    // Clear any previous transition\n    this.path.style.transition = this.path.style.WebkitTransition = 'none';\n\n    // Set up the starting position\n    this.path.style.strokeDasharray = length + ' ' + length;\n    this.path.style.strokeDashoffset = length;\n\n    // Trigger a Layout so styles are re-calculated\n    // A browser picks up the starting position before animating\n    this.path.getBoundingClientRect();\n\n    // Define our transition\n    this.path.style.transition = this.path.style.WebkitTransition = 'stroke-dashoffset ' + speed + 'ms' + ' ease-in';\n\n    // Go.\n    this.path.style.strokeDashoffset = '0';\n\n    setTimeout(() => {\n      this.path.style.removeProperty('transition');\n      this.path.style.removeProperty('stroke-dasharray');\n      this.path.style.removeProperty('stroke-dashoffset');\n    }, speed)\n  };\n\n  scaleX(scaling){\n    let oldTransform = this.path.style.transform;\n\n    if (oldTransform.includes('scaleX')){\n      this.path.style.transform = oldTransform.replace(/(scaleX\\(\\S+\\))/, `scaleX(${scaling})`)\n    } else {\n      this.path.style.transform = oldTransform + ` scaleX(${scaling})`;\n    }\n  }\n\n  scaleY(scaling){\n    let oldTransform = this.path.style.transform;\n\n    if (oldTransform.includes('scaleY')){\n      this.path.style.transform = oldTransform.replace(/(scaleY\\(\\S+\\))/, `scaleY(${scaling})`)\n    } else {\n      this.path.style.transform = oldTransform + ` scaleY(${scaling})`;\n    }\n  }\n\n  get isHidden(){\n    return this.path.classList.contains(Path.CSS.graphHidden);\n  }\n\n  toggleVisibility(){\n    this.path.classList.toggle(Path.CSS.graphHidden);\n  }\n}","import * as Dom from '../utils/dom';\nimport * as Numbers from '../utils/numbers';\nimport Path from './path';\n\n/**\n * Working with svg paths for charts\n */\nexport default class Graph {\n  /**\n   * @param {State} state\n   */\n  constructor(state, {stroke}){\n    /**\n     * Width of date label is used for default stepX value in 1:1 scale\n     * @type {number}\n     */\n    const dateLabelWidth = 45;\n\n    this.state = state;\n    /**\n     * @todo move to this.nodes\n     */\n    this.canvas = undefined;\n    this.legend = undefined;\n    this.grid = undefined;\n\n\n    this.stepX = dateLabelWidth;\n    this.stepY = 10;\n    this.strokeWidth = stroke;\n    this.initialWidth = undefined;\n    this.maxPoint = this.state.max * 1.2; // 20% for padding top\n\n    /**\n     * List of drawn lines\n     * @type {object} name -> Path\n     */\n    this.paths = {};\n  }\n\n  static get CSS(){\n    return {\n      grid: 'tg-grid',\n      gridSection: 'tg-grid__section'\n    }\n  }\n\n  /**\n   * Return Graph's paths as array\n   * @return {Path[]}\n   */\n  get pathsList(){\n    return Object.entries(this.paths).map(([name, path]) => {\n      return path;\n    });\n  }\n\n\n  /**\n   * Prepares the SVG element\n   * @param {number} [width] - strict canvas width\n   * @param {number} [height] - strict canvas height\n   * @return {SVGElement}\n   */\n  renderCanvas({width, height} = {}){\n    this.canvas = Dom.make('svg');\n\n    if (!width){\n      this.setCanvasWidth();\n    } else {\n      this.canvas.style.width = width + 'px';\n      this.initialWidth = width;\n    }\n\n    if (height){\n      this.canvas.style.height = height + 'px';\n    }\n\n    this.computeSteps();\n\n    return this.canvas;\n  }\n\n  setCanvasWidth(){\n    this.initialWidth = this.state.daysCount * this.stepX;\n    this.canvas.style.width = this.initialWidth + 'px';\n\n  }\n\n  get width(){\n    return parseInt(this.canvas.style.width, 10);\n  }\n\n  get height(){\n    /**\n     * @todo unhardcode padding top\n     */\n    return parseInt(this.canvas.style.height, 10);\n  }\n\n  /**\n   * Calculates stepX by canvas width and total points count\n   */\n  computeSteps(){\n    this.stepX = Math.ceil(parseInt(this.canvas.style.width, 10) / this.state.daysCount);\n    /**\n     * All lines maximum value\n     */\n    const max = this.state.max;\n    const stepsAvailable = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000];\n    this.stepY = stepsAvailable.reverse().find( step => max > step );\n  }\n\n\n  /**\n   * Renders a line by name\n   * @param {string} name - line name (\"y0\", \"y1\" etc)\n   */\n  renderLine(name){\n    /**\n     * Array of chart Y values\n     */\n    const values = this.state.getLinePoints(name);\n\n    /**\n     * Color of drawing line\n     */\n    const color = this.state.getLineColor(name);\n\n    /**\n     * Point to from which we will start drawing\n     */\n    const leftPoint = values[0];\n\n    /**\n     * Create a Path instance\n     */\n    const path = new Path({\n      svg: this.canvas,\n      color,\n      max: this.maxPoint,\n      stroke: this.strokeWidth,\n      stepX: this.stepX,\n    });\n\n    path.moveTo(0, leftPoint);\n\n    values.forEach( column => {\n      // path.dropText(column);  for testing purposes\n      path.stepTo(column);\n    });\n\n    path.render();\n\n    this.paths[name] = path;\n  }\n\n  renderGrid(forceMax){\n    if (this.grid){\n      this.grid.remove();\n    }\n\n    this.grid = Dom.make('div', Graph.CSS.grid);\n\n    let stepY = this.stepY;\n    const height = this.height;\n    const width = this.width;\n    const max = forceMax || this.maxPoint;\n    const kY = height / max;\n\n    let linesCount = height / (stepY * kY) >> 0;\n\n    if (linesCount === 0){\n      stepY = stepY / 3;\n      linesCount = height / (stepY * kY) >> 0;\n    }\n\n    // Drawing horizontal lines\n\n    for (let j = 0; j <= linesCount; j++) {\n      let y = j * stepY;\n\n      let line = Dom.make('div', Graph.CSS.gridSection);\n\n      if (j === 0){\n        line.classList.add('no-animation');\n      }\n\n      line.style.bottom = y * kY + 'px';\n      line.textContent = Numbers.beautify(Math.round(y));\n\n      this.grid.appendChild(line);\n    }\n\n    /**\n     * @todo pass this.wrapper or something\n     */\n    Dom.insertBefore(this.canvas.parentNode, this.grid);\n  }\n\n  /**\n   * Renders a legend with dates\n   * @param {number[]} dates\n   */\n  renderLegend(dates){\n    this.legend = Dom.make('footer');\n\n    dates.forEach((date, index) => {\n      /**\n       * Skip every second\n       */\n      if (index % 2 === 1){\n        return;\n      }\n\n      const dt = new Date(date);\n      const dateEl = Dom.make('time');\n      dateEl.textContent = dt.toLocaleDateString('en-US', {\n        day: 'numeric',\n        month: 'short'\n      });\n\n      this.legend.appendChild(dateEl)\n    });\n\n    Dom.insertAfter(this.canvas, this.legend);\n  }\n\n  /**\n   * Scale left legend\n   * @param {number} scaling\n   */\n  scaleLines(scaling){\n    this.pathsList.forEach( path => {\n      path.scaleX(scaling);\n    });\n\n    const newWidth = this.initialWidth * scaling;\n    this.canvas.style.width = newWidth + 'px';\n\n    const canFit = Math.round(newWidth / this.stepX);\n    const nowFit = Math.round(this.initialWidth / this.stepX);\n    const fitability = Math.floor(nowFit / canFit + 0.9);\n\n    if (fitability % 2 === 1){\n      this.legend.classList.add(`skip-${fitability}`);\n    }\n\n    this.legend.classList.toggle('skip-odd', nowFit / canFit > 1.7);\n    this.legend.classList.toggle('skip-odd', nowFit / canFit > 1.7);\n    this.legend.classList.toggle('skip-third', nowFit / canFit > 3.8);\n    this.legend.classList.toggle('skip-fifth', nowFit / canFit > 5.5);\n    this.legend.classList.toggle('skip-seventh', nowFit / canFit > 7);\n  }\n\n  get step(){\n    return this.stepX;\n  }\n\n  scaleToMaxPoint(newMax){\n    let scaling = this.maxPoint / newMax * 0.8;\n\n    this.pathsList.forEach( path => {\n      path.scaleY(scaling);\n    });\n\n    this.renderGrid(newMax * 1.2);\n  }\n\n  checkPathVisibility(name){\n    return !this.paths[name].isHidden;\n  }\n\n  togglePathVisibility(name){\n    this.paths[name].toggleVisibility();\n  }\n}","import * as Dom from '../utils/dom.js';\nimport Graph from './graph.js';\n\n\n/**\n * Module for working with Chart Mini map\n * - Render UI\n * - Render graphs\n * - Scaling\n * - Scrolling\n */\nexport default class Minimap {\n  constructor(modules){\n    this.modules = modules;\n    /**\n     * @param {State} state\n     */\n    this.state = modules.state;\n    this.nodes = {\n      wrapper: undefined,\n      canvas: undefined,\n\n      leftZone: undefined,\n      leftZoneScaler: undefined,\n      rightZone: undefined,\n      rightZoneScaler: undefined,\n    };\n\n    this.wrapperWidthCached = undefined;\n    this.viewportWidth = 100;\n    this.viewportWidthInitial = 100;\n    this.viewportOffsetLeft = 0;\n\n    /**\n     * Clicked pageX\n     */\n    this.moveStartX = undefined;\n\n    /**\n     * Clicked layerX\n     */\n    this.moveStartLayerX = undefined;\n    this.wrapperLeftCoord = undefined;\n\n    /**\n     * Indicator that viewport zone is dragged\n     */\n    this.viewportPressed = false;\n\n    /**\n     * Indicator that left scaler zone is dragged\n     */\n    this.leftScalerClicked = false;\n\n    /**\n     * Indicator that right scaler zone is dragged\n     */\n    this.rightScalerClicked = false;\n\n    this.graph = new Graph(this.state, {\n      stroke: 1\n    });\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-minimap',\n      leftZone: 'tg-minimap__left',\n      leftZoneScaler: 'tg-minimap__left-scaler',\n      rightZone: 'tg-minimap__right',\n      rightZoneScaler: 'tg-minimap__right-scaler',\n    }\n  }\n\n  /**\n   * Prepares minimap UI\n   * @return {Element}\n   */\n  renderUi(){\n    this.nodes.wrapper = Dom.make('div', Minimap.CSS.wrapper);\n    this.nodes.leftZone = Dom.make('div', Minimap.CSS.leftZone);\n    this.nodes.rightZone = Dom.make('div', Minimap.CSS.rightZone);\n    this.nodes.leftZoneScaler = Dom.make('div', Minimap.CSS.leftZoneScaler);\n    this.nodes.rightZoneScaler = Dom.make('div', Minimap.CSS.rightZoneScaler);\n\n    this.nodes.leftZone.appendChild(this.nodes.leftZoneScaler);\n    this.nodes.rightZone.appendChild(this.nodes.rightZoneScaler);\n\n    this.nodes.wrapper.appendChild(this.nodes.leftZone);\n    this.nodes.wrapper.appendChild(this.nodes.rightZone);\n\n    this.bindEvents();\n\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Fill UI with chart and set initial Position\n   */\n  renderMap(){\n    this.nodes.canvas = this.graph.renderCanvas({\n      width: this.nodes.wrapper.offsetWidth,\n      height: this.nodes.wrapper.offsetHeight\n    });\n\n    this.state.linesAvailable.forEach( name => {\n      this.graph.renderLine(name);\n    });\n\n    this.setInitialPosition();\n\n    this.nodes.wrapper.appendChild(this.nodes.canvas);\n  }\n\n  /**\n   * Return width of a mini map\n   * @return {number}\n   */\n  get wrapperWidth(){\n    return this.wrapperWidthCached || this.nodes.wrapper.offsetWidth;\n  }\n\n  /**\n   * Compute current minimap width\n   * @return {number}\n   */\n  get width(){\n    return this.wrapperWidth - parseInt(this.nodes.leftZone.style.width, 10) - parseInt(this.nodes.rightZone.style.width, 10);\n  }\n\n  /**\n   * Set new with to the minimap's viewport\n   * @param value\n   */\n  set width(value){\n    const scrollDistance = this.modules.chart.scrollDistance;\n\n    this.nodes.leftZone.style.width = scrollDistance + 'px';\n    this.nodes.rightZone.style.width = this.wrapperWidth - scrollDistance - value + 'px';\n    this.viewportWidth = value;\n  }\n\n  /**\n   * Initial width and offset\n   */\n  setInitialPosition(){\n    let rect = this.nodes.wrapper.getBoundingClientRect();\n    this.wrapperWidthCached = rect.width;\n    this.wrapperLeftCoord = rect.left;\n\n    const chartToViewportRatio = this.modules.chart.viewportWidth / this.modules.chart.width;\n    this.width = this.wrapperWidth * chartToViewportRatio;\n    this.viewportWidthInitial = this.width;\n    this.viewportOffsetLeft = 0;\n    this.moveViewport(this.viewportOffsetLeft);\n    this.syncScrollWithChart();\n  }\n\n  /**\n   * Current scroll value\n   * @return {number}\n   */\n  get scrolledValue(){\n    return parseInt(this.nodes.leftZone.style.width, 10);\n  }\n\n  /**\n   * Moves viewport from left for passed value\n   * @param {string} offsetLeft\n   */\n  moveViewport(offsetLeft){\n    const width = this.width;\n    const maxLeft = this.wrapperWidth - width;\n    const minLeft = 0;\n\n    let newLeft = this.viewportOffsetLeft + offsetLeft;\n\n    if (newLeft < minLeft){\n      newLeft = minLeft;\n    } else if (newLeft > maxLeft){\n      newLeft = maxLeft;\n    }\n    this.nodes.leftZone.style.width = newLeft + 'px';\n    this.nodes.rightZone.style.width = this.wrapperWidth - width - newLeft;\n  }\n\n  bindEvents(){\n    this.nodes.wrapper.addEventListener('mousedown', (event) => {\n      this.viewportMousedown(event);\n    });\n\n    this.nodes.wrapper.addEventListener('mousemove', (event) => {\n      this.viewportMousemove(event);\n    });\n\n    this.nodes.wrapper.addEventListener('mouseleave', (event) => {\n      this.viewportMouseleave(event);\n    });\n\n    this.nodes.wrapper.addEventListener('mouseup', (event) => {\n      this.viewportMouseup(event);\n    });\n\n    /**\n     * @todo add support to touches\n     * （╯°□°）╯︵( .o.)\n     */\n\n    this.nodes.wrapper.addEventListener('touchstart', (event) => {\n      this.viewportMousedown(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchmove', (event) => {\n      this.viewportMousemove(event);\n   });\n\n    this.nodes.wrapper.addEventListener('touchcancel', (event) => {\n      this.viewportMouseleave(event);\n    });\n\n    this.nodes.wrapper.addEventListener('touchend', (event) => {\n      this.viewportMouseup(event);\n    });\n  }\n\n  /**\n   * Viewport under finger\n   * @param {MouseEvent|TouchEvent} event\n   */\n  viewportMousedown(event){\n    const {target} = event;\n\n    event.preventDefault();\n\n    const leftScalerClicked = !!target.closest(`.${Minimap.CSS.leftZoneScaler}`);\n    const rightScalerClicked = !!target.closest(`.${Minimap.CSS.rightZoneScaler}`);\n\n    this.moveStartX = !event.touches ? event.pageX : event.touches[0].pageX;\n    this.moveStartLayerX = !event.touches ? event.layerX : event.touches[0].layerX;\n\n    if (leftScalerClicked || rightScalerClicked){\n      this.leftScalerClicked = leftScalerClicked;\n      this.rightScalerClicked = rightScalerClicked;\n      this.viewportPressed = false;\n      return;\n    }\n\n    this.viewportPressed = true;\n  }\n\n  /**\n   * Viewport dragged\n   * @param {MouseEvent} event\n   */\n  viewportMousemove(event){\n    if (this.viewportPressed){\n      this.viewportDragged(event);\n    } else if (this.leftScalerClicked){\n      this.scalerDragged(event, 'left');\n    } else if (this.rightScalerClicked){\n      this.scalerDragged(event, 'right');\n    }\n  }\n\n  /**\n   * Viewport dragend\n   * @param {MouseEvent} event\n   */\n  viewportMouseleave(event){\n    if (this.viewportPressed){\n      this.finishSliding();\n    } else if (this.leftScalerClicked){\n      this.finishLeftScaling();\n    } else if (this.rightScalerClicked){\n      this.finishRightScaling();\n    }\n  }\n\n  viewportMouseup(){\n    if (this.viewportPressed){\n      this.finishSliding();\n    } else if (this.leftScalerClicked){\n      this.finishLeftScaling();\n    } else if (this.rightScalerClicked){\n      this.finishRightScaling();\n    }\n  }\n\n  finishSliding(){\n    this.viewportPressed = false;\n    this.viewportOffsetLeft = parseInt(this.scrolledValue, 10);\n  }\n\n  finishLeftScaling(){\n    this.leftScalerClicked = false;\n  }\n\n  finishRightScaling(){\n    this.rightScalerClicked = false;\n  }\n\n  /**\n   * @param {MouseEvent} event\n   */\n  viewportDragged(event){\n    let delta = event.pageX - this.moveStartX;\n\n    if (event.touches) {\n      delta = event.touches[0].pageX;\n    }\n\n    this.moveViewport(delta);\n    this.syncScrollWithChart();\n\n    /**\n     * @todo add debounce\n     */\n    this.modules.chart.fitToMax();\n  }\n\n  syncScrollWithChart(){\n    /**\n     * How many percents of mini-map is scrolled\n     */\n    const minimapScrolledPortion = this.scrolledValue / this.wrapperWidth;\n    const chartScroll = minimapScrolledPortion * this.modules.chart.width;\n\n    this.modules.chart.scroll(chartScroll);\n  }\n\n  /**\n   * Viewport side-scaler is moved\n   * @param {MouseEvent} event\n   * @param {string} direction — 'left' or 'right'\n   */\n  scalerDragged(event, side){\n    let delta = event.layerX - this.moveStartLayerX;\n    let pullDirection = event.pageX - this.moveStartX < 0 ? 'left' : 'right';\n\n    if (!delta){\n      return;\n    }\n\n    /**\n     * Workaround case with fast-forward dragging\n     */\n    if (delta > 5){\n      delta = 5;\n\n      if (side === 'left'){\n        delta = pullDirection === 'left' ? -5 : 5;\n      }\n    } else if (delta < -5){\n      delta = -5;\n    }\n\n    if (side === 'left'){\n      delta = delta * -1;\n      this.nodes.leftZone.style.width = parseInt(this.nodes.leftZone.style.width) - delta + 'px';\n      this.syncScrollWithChart();\n    } else {\n      this.nodes.rightZone.style.width = parseInt(this.nodes.rightZone.style.width) - delta + 'px';\n    }\n\n    const scaling = this.viewportWidthInitial / this.width ;\n    this.modules.chart.scale(scaling);\n    this.modules.chart.fitToMax();\n  }\n}","import * as Dom from '../utils/dom.js';\nimport * as Numbers from '../utils/numbers';\n\nexport default class Tooltip {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper:  undefined,\n      title: undefined,\n      values: undefined\n    }\n  }\n\n  /**\n   * CSS map\n   * @return {{wrapper: string, title: string, values: string, value: string}}\n   */\n  static get CSS(){\n    return {\n      wrapper: 'tg-tooltip',\n      showed: 'tg-tooltip--showed',\n      title: 'tg-tooltip__title',\n      values: 'tg-tooltip__values',\n      value: 'tg-tooltip__values-item',\n    }\n  }\n\n  render(){\n    this.nodes.wrapper = Dom.make('div', Tooltip.CSS.wrapper);\n    this.nodes.title = Dom.make('div', Tooltip.CSS.title);\n    this.nodes.values = Dom.make('div', Tooltip.CSS.values);\n\n    this.nodes.wrapper.appendChild(this.nodes.title);\n    this.nodes.wrapper.appendChild(this.nodes.values);\n\n    return this.nodes.wrapper;\n  }\n\n  show(){\n    this.nodes.wrapper.classList.add(Tooltip.CSS.showed);\n  }\n\n  hide(){\n    this.nodes.wrapper.classList.remove(Tooltip.CSS.showed);\n  }\n\n  move(lineLeftCoord){\n    let offsetLeft = -25;\n    const tooltipWidth = this.nodes.wrapper.offsetWidth;\n\n    if (lineLeftCoord > this.modules.chart.viewportWidth - tooltipWidth / 3){\n      offsetLeft = -1.1 * tooltipWidth;\n    } else if (lineLeftCoord > this.modules.chart.viewportWidth - tooltipWidth ){\n      offsetLeft = -0.8 * tooltipWidth;\n    } else if (lineLeftCoord < 45){\n      offsetLeft = 20;\n    }\n\n    this.nodes.wrapper.style.left = `${lineLeftCoord + offsetLeft}px`;\n  }\n\n  clear(){\n    this.nodes.title.textContent = '';\n    this.nodes.values.innerHTML = '';\n  }\n\n  /**\n   * Render values of current hovered points\n   * @param {{name: string, value: number}[]} values\n   */\n  set values(values){\n    this.clear();\n\n    values.forEach( ({name, value}) => {\n      const item = Dom.make('div', Tooltip.CSS.value);\n      const color = this.modules.state.colors[name];\n      const title = this.modules.state.names[name];\n\n\n      item.innerHTML = `<b>${Numbers.beautify(value)}</b>${title}`;\n      item.style.color = color;\n\n      this.nodes.values.appendChild(item);\n    })\n  }\n\n  set title(string){\n    this.nodes.title.innerHTML = string;\n  }\n}","import * as Dom from '../utils/dom.js';\nimport Graph from './graph.js';\nimport Tooltip from \"./tooltip\";\n\n/**\n * Module for working with main Chart zone\n * - Render UI\n * - Render axes\n * - Render graphs\n * - Toggle lines visibility\n */\nexport default class Chart {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    /**\n     * @param {State} state\n     */\n    this.state = modules.state;\n    this.nodes = {\n      wrapper: undefined,\n      viewport: undefined,\n      canvas: undefined,\n      cursorLine: undefined\n    };\n\n    this.tooltip = new Tooltip(this.modules);\n    this.graph = new Graph(this.state, {\n      stroke: 3\n    });\n\n    this.wrapperLeftCoord = undefined;\n    this.scaling = 1;\n    this.scrollValue = 0;\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-chart',\n      viewport: 'tg-chart__viewport',\n      cursorLine: 'tg-chart__cursor-line'\n    }\n  }\n\n  /**\n   * Return current scroll distance\n   * @return {number}\n   */\n  get scrollDistance() {\n    return this.scrollValue * this.scaling;\n  }\n\n  /**\n   * Return current scaling value\n   * @return {number|*}\n   */\n  get scalingValue(){\n    return this.scaling;\n  }\n\n  renderUi(){\n    this.nodes.wrapper = Dom.make('div', Chart.CSS.wrapper);\n    this.nodes.viewport = Dom.make('div', Chart.CSS.viewport);\n    this.nodes.cursorLine = Dom.make('div', Chart.CSS.cursorLine);\n\n    this.nodes.wrapper.appendChild(this.nodes.viewport);\n    this.nodes.wrapper.appendChild(this.nodes.cursorLine);\n\n    this.nodes.wrapper.appendChild(this.tooltip.render());\n\n    this.bindEvents();\n\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Renders charts\n   */\n  renderCharts(){\n    this.calculateWrapperCoords();\n\n    /**\n     * @todo pass height through the initial settings\n     */\n    this.nodes.canvas = this.graph.renderCanvas({\n      height: 400\n    });\n    this.nodes.viewport.appendChild(this.nodes.canvas);\n\n    const dates = this.state.dates;\n\n    this.state.linesAvailable.forEach( name => {\n      this.graph.renderLine(name);\n    });\n\n    this.graph.renderGrid();\n    this.graph.renderLegend(dates);\n  }\n\n  get width(){\n    return this.graph.width;\n  }\n\n  get viewportWidth(){\n    return this.nodes.wrapper.offsetWidth;\n  }\n\n  get viewportHeight(){\n    return this.nodes.wrapper.offsetHeight;\n  }\n\n  /**\n   * Perform scroll\n   * @param position\n   */\n  scroll(position){\n    let newLeft = position * -1;\n    this.nodes.viewport.style.transform = `translateX(${newLeft}px)`;\n    this.scrollValue = newLeft;\n  }\n\n  /**\n   * Perform scaling\n   * @param {number} scaling\n   */\n  scale(scaling){\n    this.graph.scaleLines(scaling);\n\n    this.scaling = scaling;\n  }\n\n  /**\n   * Left visible point\n   * @return {number}\n   */\n  get leftPointIndex(){\n    return Math.round(this.scrollValue * -1/ this.graph.step / this.scaling);\n  }\n\n  /**\n   * Filter to skip hidden line\n   * @param {string} line - name of the graph\n   * @return {boolean}\n   */\n  notHiddenGraph(line){\n    return this.graph.checkPathVisibility(line);\n  }\n\n  /**\n   * Upscale or downscale graph to fit visible points\n   */\n  fitToMax(){\n    const stepX = this.graph.step;\n    const pointsVisible = Math.round(this.viewportWidth / stepX / this.scaling);\n    const maxVisiblePoint = Math.max(...this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).map(line => {\n      let slice = this.state.getPointsSlice(line, this.leftPointIndex, pointsVisible);\n      return Math.max(...slice);\n    }));\n\n    this.graph.scaleToMaxPoint(maxVisiblePoint);\n  }\n\n  /**\n   * Store wrapper rectangle data\n   */\n  calculateWrapperCoords(){\n    let rect = this.nodes.wrapper.getBoundingClientRect();\n\n    this.wrapperLeftCoord = rect.left;\n  }\n\n  bindEvents(){\n    this.nodes.wrapper.addEventListener('mousemove', (event) => {\n      this.mouseMove(event);\n    });\n\n    this.nodes.wrapper.addEventListener('mouseleave', (event) => {\n      this.mouseLeave(event);\n    });\n  }\n\n  /**\n   * Shows line with Tooltip\n   * @param {MouseEvent} event\n   */\n  mouseMove(event){\n    let viewportX = event.pageX - this.wrapperLeftCoord ;\n    let pointIndex = Math.round(viewportX / this.graph.stepX / this.scaling);\n\n    this.tooltip.show();\n\n    let scrollOffset = this.scrollValue % this.graph.stepX;\n    let newLeft = pointIndex * this.graph.stepX * this.scaling;\n\n    this.nodes.cursorLine.style.left = `${newLeft + scrollOffset}px`;\n\n    const hoveredPointIndex = this.leftPointIndex + pointIndex - 1;\n\n    const values = this.state.linesAvailable.filter(line => this.notHiddenGraph(line)).map( line => {\n      return {\n        name: line,\n        value: this.state.getLinePoints(line)[hoveredPointIndex]\n      }\n    });\n\n    const date = this.state.dates[hoveredPointIndex];\n\n    /**\n     * Skip bounding empty positions\n     */\n    if (!date){\n      return;\n    }\n\n    this.tooltip.values = values;\n    this.tooltip.move(newLeft);\n    this.tooltip.title = (new Date(date)).toLocaleDateString('en-US', {\n      day: 'numeric',\n      month: 'short',\n      weekday: 'short'\n    });\n  }\n\n  mouseLeave(){\n    this.tooltip.hide();\n  }\n\n  /**\n   * Toggle path visibility\n   * @param {string} name - graph name\n   */\n  togglePath(name){\n    this.graph.togglePathVisibility(name);\n    this.fitToMax();\n  }\n}","import * as Dom from '../utils/dom.js';\n\nexport default class Legend {\n  /**\n   * @param {Telegraph} modules\n   */\n  constructor(modules){\n    this.modules = modules;\n    this.nodes = {\n      wrapper: undefined,\n    };\n\n    this.buttons = {};\n  }\n\n  static get CSS(){\n    return {\n      wrapper: 'tg-legend',\n      item: 'tg-legend__item',\n      itemEnabled: 'tg-legend__item--enabled',\n      checkbox: 'tg-legend__checkbox',\n    }\n  }\n\n  /**\n   * Show graphs togglers\n   * @return {Element}\n   */\n  render(){\n    this.nodes.wrapper = Dom.make('div', Legend.CSS.wrapper);\n\n    /**\n     * Object with names -> array with names\n     */\n    const namesArray = Object.entries(this.modules.state.names).map(([name, title]) => {\n      return {name, title}\n    });\n\n    namesArray.forEach(({name, title}) => {\n      let item = Dom.make('div', [Legend.CSS.item, Legend.CSS.itemEnabled]),\n        checkbox = Dom.make('span', Legend.CSS.checkbox);\n\n      checkbox.style.borderColor = this.modules.state.colors[name];\n      checkbox.style.backgroundColor = this.modules.state.colors[name];\n\n      item.appendChild(checkbox);\n      item.appendChild(document.createTextNode(title));\n\n      this.buttons[name] = item;\n\n      item.addEventListener('click', () => {\n        this.itemClicked(name);\n      });\n\n      this.nodes.wrapper.appendChild(item);\n    });\n    return this.nodes.wrapper;\n  }\n\n  /**\n   * Click handler for togglers\n   * @param {string} name - graph name\n   */\n  itemClicked(name){\n    this.modules.chart.togglePath(name);\n    this.buttons[name].classList.toggle(Legend.CSS.itemEnabled);\n\n    const checkbox = this.buttons[name].querySelector(`.${Legend.CSS.checkbox}`);\n\n    /**\n     * @todo add animation\n     */\n    if (this.buttons[name].classList.contains(Legend.CSS.itemEnabled)){\n      checkbox.style.backgroundColor = this.modules.state.colors[name];\n    } else {\n      checkbox.style.backgroundColor = 'transparent';\n    }\n  }\n}\n","import State from './modules/state';\nimport Minimap from './modules/minimap.js';\nimport Chart from './modules/chart.js';\nimport Legend from './modules/legend.js';\n\n/**\n * @typedef {object} ChartData\n * @property {array} columns – List of all data columns in the chart.\n *                             0 - position (\"x\", \"y0\", \"y1\")\n *                             1+ - values\n *                             \"x\" values are UNIX timestamps in milliseconds.\n * @property {{x, y0, y1}} types – Chart types for each of the columns.\n *                                 Supported values:\n *                                 \"line\" (line on the graph with linear interpolation),\n *                                 \"x\" (x axis values for each of the charts at the corresponding positions).\n * @property {{y0: string, y1: string}} colors – Color for each line in 6-hex-digit format (e.g. \"#AAAAAA\").\n * @property {{y0: string, y1: string}} names – Names for each line.\n */\n\nexport default class Telegraph {\n  /**\n   * Main entry constructor\n   * @param {string} holderId - where to append a Chart\n   * @param {ChartData} inputData - chart data\n   */\n  constructor({holderId, inputData}){\n    this.holder = document.getElementById(holderId);\n\n    /**\n     * Module that stores all main app state values\n     */\n    this.state = new State(inputData);\n\n    /**\n     * Module for mini map\n     */\n    this.minimap = new Minimap(this);\n\n    /**\n     * Working with main chart zone\n     */\n    this.chart = new Chart(this);\n\n    /**\n     * Working with legend items\n     */\n    this.legend = new Legend(this);\n\n    /**\n     * Create base UI elements\n     */\n    this.prepareUi();\n\n    /**\n     * Render chart and minimap\n     */\n    this.chart.renderCharts();\n    this.minimap.renderMap()\n  }\n\n  /**\n   * Create base app UI\n   */\n  prepareUi(){\n    this.holder.appendChild(this.chart.renderUi());\n    this.holder.appendChild(this.minimap.renderUi());\n    this.holder.appendChild(this.legend.render());\n  }\n}"],"sourceRoot":""}